객체가 2단계 이상으로 깊어질 때 재귀함수 또는 `JSON.parse`,`JSON.stringify` 를 사용해 깊은 복사를 한다

# 3.4 함수형 프로그래밍과 모나드
## 순수함수와 참조 투명성
순수함수는 들어오는 값으로 결과 도출(외부의 값에 의존하면 안된다)
순수함수로 구성된 로직은 메모리를 공유해도 아무 문제가 없다(계산이 많은 로직에서 사용된다)

1. 최대한 지역 변수만을 삳용해 구현
2. 인수로 넘기는 값의 본체까지 수정하지 않기
3. 매개변수로 넘기는 값이 객체라면 원본 객체에 변이를 일으키지 않기(깊은 복사 하는 등의 방법 사용)

## 고차함수
함수가 다른 함수를 매개변수로 받아 어떤 로직을 생성하는 함수


## 커링
예상되는 여러 개의 매개변수보다 적은 수의 매개변수를 받아 매개변수가 완전히 채워지면 실행하는 기법(클로저 때문에 가능하다, 책에서는 ramda.js 라이브러리를 이용했다)

## 파괴적인 함수 쓰지 않기
함수형 프로그래밍에서 중요한 점은 최대한 원래의 변수가 그대로 있어야 한다는 점이다

splice는 배열을 파괴한다, slice는 파괴하지 않고 배열 요소들을 추출해낼 수 있다

이런 `splice`와 같은 함수를 비순수 함수라고 한다

## 무인수 프로그래밍
매개변수만을 바꿔 로직을 유연하게 수정하는 것

## 모나드
컨텍스트 레벨을 값 레 벨로 끌여들여? 추상화한 컨테이너 박스
함수형 프로그래밍에서는 참조 투명성을 위해 모나드를 사용한다
> 함수 합성을 할 때 안전하게 컨테이너 박스 안에서 연산을 실행하게 한다

모나드에는 아이덴티티 모나드와 퓨처 모나드 등이 있다

## 모나드의 조건
1. 타입을 매개변수로 받아 모나드화된 타입을 반환할 수 있어야 한다
2. unit하수가 있어야 한다
3. bind함수가 있어야 한다

## 클로저
클로저란 외부함수의 실행 컨텍스트가 소멸해도`[[scope]]`프로퍼티가 가르키는 외부 함수의 실행환경이 소멸하지 않고 참조할 수 있는 것
클로저로 독특한 함수체제를 멋지게 활용할 수 있다
1. 프라이빗 변수 모방
2. 가상의 블록 스코프 변수 생성

## DeepDive
자바스크립트는 코드 실행에 필요한 정보를 **물리적 객체**인 실행 컨텍스트를 통해 관리한다

이러한 실행컨텍스트들이 콜스택에 쌓여 순차적으로 실행된다
> Global Object인 빌트인 객체(Math,String,Array) 와 BOM DOM > 실행컨텍스트

실행컨텍스트는 
1. 스코프 체인
2. Variable Object
3. this
로 구성되고, 순차적으로 결정된다

* 생성자 함수 만들기
책에서 예시로 생성자를 `this.~` 를 해서 만들었지만, `this` 를 활용해 생성자를 만드는 방법을 추천하지 않는다고 한다

* 자바스크립트의 global객체
브라우저 환경에서 `var`,`const`,`let`이 아닌 그냥 `name = 1` 이라고 한다면, 계속해서 ㄷ위의 객체들을 찾게되고, 결국 브라우저의 최상위 객체인 `window`객체에 바인딩 된다

하지만 Node.js에서 global은 moudle그 자체이다, a.js라는 파일에 `name = 1`을 한다면 그저 a.js라는 모듈의 전역변수가 된다,

하지만 Node.js에서도 global이라는 것은 존재한다

```js
global.test = "foo"
console.log(test)
```

`__dirname` 이나 `__filename` 처럼 선언하지 않았음에도 사용할 수 있는 것과 같다

* call과 apply, bind로 정해지는 this
`.call` 과 `.apply`는 함수 호출에 사용된다